<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scroll‑Player Article</title>
  <style>
    :root{
      --bg:#0b1220; --ink:#e9eefc; --muted:#a9b4d6; --accent:#62d0ff; --accent2:#ffd166;
      --card:#121a2e; --shadow:rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; font: 16px/1.65 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Apple Color Emoji, Segoe UI Emoji; color:var(--ink); background:radial-gradient(1200px 700px at 10% -10%, #12203b 0%, #0b1220 60%);}    
    main{width:min(920px, 92vw); margin:0 auto; padding:18vh 0 24vh 0; position:relative;}
    section{background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01)); border:1px solid rgba(255,255,255,.06); border-radius:20px; padding:28px; margin:48px 0; box-shadow:0 12px 30px var(--shadow);}    
    h1,h2{margin:0 0 12px 0; line-height:1.2}
    h1{font-size:clamp(28px, 3.5vw, 46px)}
    h2{font-size:clamp(22px, 2.4vw, 30px); color:var(--accent)}
    p{margin:10px 0}

    /* Player (always centered vertically; world scrolls under it) */
    #player{
      position:fixed; z-index:20; left:50%; top:50%; width:44px; height:44px; transform:translate(-50%, -50%);
      border-radius:12px; background:linear-gradient(160deg, var(--accent), #7ee0ff);
      box-shadow:0 10px 24px rgba(0,0,0,.45), inset 0 2px 6px rgba(255,255,255,.5);
      outline:2px solid rgba(255,255,255,.35);
    }
    #player::before,#player::after{content:""; position:absolute; top:14px; width:6px; height:6px; background:#0b1220; border-radius:50%}
    #player::before{left:12px} #player::after{right:12px}
    #shadow{position:fixed; left:50%; top:calc(50% + 28px); width:60px; height:14px; transform:translateX(-50%); background:radial-gradient(ellipse at center, rgba(0,0,0,.45), rgba(0,0,0,0) 60%); filter:blur(3px); z-index:10}

    /* HUD */
    #hud{position:fixed; z-index:30; top:16px; left:50%; transform:translateX(-50%); background:rgba(10,16,28,.7); backdrop-filter:blur(8px); border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:10px 14px; display:flex; gap:14px; align-items:center}
    #hud .pill{font-size:13px; color:var(--muted)}
    #hud kbd{background:#10182b; border:1px solid rgba(255,255,255,.1); border-radius:8px; padding:2px 6px; box-shadow:inset 0 1px 0 rgba(255,255,255,.08)}
    #hud button{cursor:pointer; border:1px solid rgba(255,255,255,.12); background:#0f1830; color:var(--ink); border-radius:10px; padding:6px 10px; font-weight:600}
    #hud button:hover{background:#0e1a36}

    /* Progress bar */
    #progress{position:fixed; z-index:25; right:20px; top:20px; width:10px; height:60vh; border-radius:999px; background:rgba(255,255,255,.08); overflow:hidden;}
    #progress>span{display:block; width:100%; height:0%; background:linear-gradient(180deg, var(--accent2), var(--accent));}

    /* Section highlight when near center */
    section.in-view{outline:2px solid rgba(255,255,255,.25); box-shadow:0 18px 40px rgba(0,0,0,.6)}

    /* Platform layer (world-attached) */
    #platLayer{position:absolute; inset:0; z-index:12; pointer-events:none}
    .plat{position:absolute; height:14px; border-radius:7px; background:linear-gradient(180deg, rgba(255,255,255,.24), rgba(255,255,255,.1)); border:1px solid rgba(255,255,255,.15); box-shadow:0 6px 14px rgba(0,0,0,.35)}

    @media (prefers-reduced-motion: reduce){ html{scroll-behavior:auto} }
  </style>
</head>
<body>
  <div id="player" aria-hidden="true" title="Use WASD/←→ to move, Space to jump"></div>
  <div id="shadow" aria-hidden="true"></div>

  <div id="hud" role="status" aria-live="polite">
    <span class="pill">Controls: <kbd>←/→</kbd> move &nbsp; <kbd>Space</kbd>/<kbd>W</kbd> jump &nbsp; <kbd>↓</kbd>/<kbd>S</kbd> dive</span>
    <button id="toggleReduced">Reduce motion</button>
  </div>
  <div id="progress" aria-hidden="true"><span></span></div>

  <main id="article">
    <div id="platLayer" aria-hidden="true"></div>

    <header style="text-align:center; margin-bottom:36px">
      <h1>Scroll‑Player Article</h1>
      <p style="color:var(--muted); max-width:62ch; margin:8px auto 0">Jump to read! The player stays centered, and the world scrolls beneath you. Great for playful docs, devlogs, or story chapters.</p>
    </header>

    <!-- Sample tall content: replace with your real article -->
    <section><h2>1) What this is</h2><p>It's an article that you can scroll with controlling a player. Quite simple.</p><p>Tip: the bar on the right fills as you fall.</p></section>
    <section><h2>2) Idea</h2><p>As the cube “falls,” gravity scrolls the page. Press <strong>Space</strong> to jump (slows descent or lifts you back toward earlier paragraphs), and press <strong>↓</strong> to dive down to the next chunk.</p></section>
    <section><h2>3) Use cases</h2><p>Devlogs, multi‑chapter docs, or a whimsical CYOA. Add anchors, images, and code blocks—everything is just normal HTML inside sections.</p></section>
    <section><h2>4) Tips</h2><p>Keep paragraphs short. Use headings every few screens so players have targets. Avoid giant images without <code>width</code>/<code>height</code> to prevent layout shift.</p></section>
    <section><h2>5) Performance</h2><p>This demo uses a tiny physics loop tied to <code>requestAnimationFrame</code> and updates <code>scrollTop</code> via a smoothed camera.</p></section>
    <section><h2>6) Accessibility</h2><p>All text is semantic HTML; the toy layer doesn’t block selection. There’s a <em>Reduce motion</em> button for sensitive users.</p></section>
    <section><h2>7) Extend</h2><p>Add parallax backgrounds, coins, or section‑based challenges (press a key to reveal the next paragraph). Or add a button to switch to plain scroll mode.</p></section>
  </main>

  <script>
    (function(){
      const progressEl = document.querySelector('#progress>span');
      const sections = Array.from(document.querySelectorAll('section'));
      const reducedBtn = document.getElementById('toggleReduced');
      const platLayer = document.getElementById('platLayer');
      const mainEl = document.getElementById('article');
      const playerEl = document.getElementById('player');
      const shadowEl = document.getElementById('shadow');

      let reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      // ===== Platforms (declare BEFORE any call sites to avoid TDZ errors) =====
      /** @type {Array<{xFrac:number,y:number,wFrac:number,h:number,el:HTMLElement,left:number,right:number,top:number,bottom:number}>} */
      const platforms = [];
      function clearPlatforms(){ platforms.length = 0; platLayer.innerHTML = ''; }
      function addPlatform(xFrac, yWorld, wFrac, h){
        const el = document.createElement('div'); el.className='plat';
        platLayer.appendChild(el);
        platforms.push({xFrac, y:yWorld, wFrac, h, el, left:0, right:0, top:yWorld, bottom:yWorld+h});
      }
      function layoutPlatforms(){
        const mainTop = mainEl.getBoundingClientRect().top + window.scrollY;
        platforms.forEach(p=>{
          const wpx = Math.max(40, p.wFrac * innerWidth);
          const lpx = p.xFrac * innerWidth - wpx/2;
          p.left = lpx; p.right = lpx + wpx; p.top = p.y; p.bottom = p.y + p.h;
          p.el.style.width = wpx+'px';
          p.el.style.height = p.h+'px';
          p.el.style.left = lpx+'px';
          p.el.style.top = (p.y - mainTop)+'px';
        });
      }
      function buildPlatforms(){
        clearPlatforms();
        // One platform per section + a right-side "ladder" track
        sections.forEach((s,i)=>{
          const r = s.getBoundingClientRect();
          const top = r.top + window.scrollY;
          const y = top + Math.min(120, r.height*0.35);
          const xFrac = (i % 2 ? 0.72 : 0.28);
          addPlatform(xFrac, y, 0.22, 14);
        });
        // Right-side climb path
        const start = (mainEl.getBoundingClientRect().top + window.scrollY) + 300;
        for(let j=0;j<8;j++) addPlatform(0.84, start + j*380, 0.16, 12);
        layoutPlatforms();
      }

      // ===== World / camera =====
      let docH = 0, camY = 0, targetCamY = 0;
      function recalc(){
        docH = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
        camY = window.scrollY | 0;
        // Build or relayout platforms safely
        if(platforms.length === 0) buildPlatforms(); else layoutPlatforms();
      }
      addEventListener('resize', recalc);
      addEventListener('load', recalc);
      recalc(); // safe now — platforms already declared

      // Player state in world coordinates
      const player = { x: 0.5, y: innerHeight * 0.5, vx: 0, vy: 0, width: 44, height: 44 };

      // Physics constants
      const G = 2400;              // px/s^2
      const JUMP = 900;            // initial jump velocity (upwards => negative vy)
      const MOVE = 520;            // horizontal speed px/s
      const CAM_SMOOTH = 0.12;     // camera follow smoothing
      const MAX_FALL = 1600;       // clamp

      // Input
      const keys = new Set();
      addEventListener('keydown', (e)=>{
        if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
        keys.add(e.key);
      });
      addEventListener('keyup', (e)=> keys.delete(e.key));

      reducedBtn.addEventListener('click', ()=>{
        reducedMotion = !reducedMotion;
        reducedBtn.textContent = reducedMotion ? 'Enable motion' : 'Reduce motion';
        if(reducedMotion){
          cancelAnimationFrame(loopHandle);
          document.body.style.overflowY = 'auto';
          progressTick();
        }else{
          document.body.style.overflowY = 'hidden';
          last = performance.now();
          loopHandle = requestAnimationFrame(loop);
        }
      });

      document.body.style.overflowY = reducedMotion ? 'auto' : 'hidden';

      // Intersection highlight near center
      function highlightInView(){
        const center = window.scrollY + innerHeight/2;
        sections.forEach(s=>{
          const r = s.getBoundingClientRect();
          const top = r.top + window.scrollY;
          const mid = top + r.height/2;
          const near = Math.abs(mid - center) < innerHeight*0.25;
          s.classList.toggle('in-view', near);
        });
      }

      // Progress bar
      function progressTick(){
        const maxScroll = Math.max(1, (docH - innerHeight));
        const pct = Math.min(1, Math.max(0, window.scrollY / maxScroll));
        progressEl.style.height = (pct*100).toFixed(1)+'%';
        highlightInView();
      }
      addEventListener('scroll', progressTick, {passive:true});

      // ===== Game loop =====
      let last = performance.now();
      let loopHandle = 0;
      let grounded = false; let jumpPrev = false; let currentGround = null;

      function loop(now){
        const dt = Math.min(0.033, (now - last) / 1000);
        last = now;

        if(!reducedMotion){
          // Horizontal
          const left = keys.has('ArrowLeft') || keys.has('a') || keys.has('A');
          const right = keys.has('ArrowRight') || keys.has('d') || keys.has('D');
          const jump = keys.has(' ') || keys.has('ArrowUp') || keys.has('w') || keys.has('W');
          const dive = keys.has('ArrowDown') || keys.has('s') || keys.has('S');

          let dvx = 0; if(left) dvx -= MOVE; if(right) dvx += MOVE;
          player.vx = dvx;

          // If grounded but we walk off the platform edges, start falling
          const px = player.x * innerWidth;
          if(grounded && currentGround){
            if(px < currentGround.left || px > currentGround.right){ grounded = false; currentGround = null; }
          }

          // Jump (on press edge only)
          if(jump && !jumpPrev && grounded){ player.vy = -JUMP; grounded = false; }
          jumpPrev = jump;

          // Apply gravity only when not grounded
          const prevY = player.y;
          if(!grounded){
            if(dive) player.vy += G * 0.8 * dt;
            player.vy += G * dt; if(player.vy > MAX_FALL) player.vy = MAX_FALL;
            player.y += player.vy * dt;
          } else {
            player.vy = 0; // locked to ground
          }

          // Move horizontally (normalized to viewport width)
          player.x += player.vx * dt / innerWidth;
          player.x = Math.max(0.06, Math.min(0.94, player.x));
          playerEl.style.left = (player.x*100)+'%';
          // Keep the shadow under the player horizontally
          shadowEl.style.left = (player.x*100)+'%';

          // World bounds
          const minY = innerHeight*0.5;
          const maxY = Math.max(minY, docH - innerHeight*0.5);
          if(player.y < minY){ player.y = minY; if(player.vy < 0) player.vy *= -0.25; }
          if(player.y > maxY){ player.y = maxY; grounded = true; currentGround = {left:-1e9,right:1e9, top:maxY + player.height/2, bottom:maxY + 1e9}; player.vy = 0; }

          // Platform collision (landing only)
          if(!grounded && player.vy >= 0){
            const prevBottom = prevY + player.height/2;
            const nextBottom = player.y + player.height/2;
            const xpx = player.x * innerWidth;
            for(const p of platforms){
              if(xpx >= p.left && xpx <= p.right){
                // crossed the top this frame
                if(prevBottom <= p.top && nextBottom >= p.top){
                  grounded = true; currentGround = p; player.y = p.top - player.height/2; player.vy = 0; break;
                }
              }
            }
          }

          // Camera follow (smooth)
          const target = Math.max(0, Math.min(docH - innerHeight, player.y - innerHeight*0.5));
          targetCamY = target;
          camY += (targetCamY - camY) * CAM_SMOOTH;
          window.scrollTo(0, camY|0);

          // Shadow squash
          const vyNorm = Math.max(-JUMP, Math.min(MAX_FALL, player.vy)) / MAX_FALL;
          const w = 60 + 20 * Math.max(0, vyNorm);
          shadowEl.style.width = w.toFixed(0)+'px';
          // Subtle opacity: fainter when airborne
          shadowEl.style.opacity = grounded ? '0.9' : '0.6';
        }

        progressTick();
        loopHandle = requestAnimationFrame(loop);
      }

      // ===== Self-tests (simple console checks) =====
      (function selfTests(){
        console.groupCollapsed('%cSelf‑tests','color:#62d0ff');
        console.assert(Array.isArray(platforms), 'platforms should be an array');
        // Build once to ensure platforms exist before checks
        if(platforms.length===0) buildPlatforms();
        const finiteBounds = platforms.every(p => [p.left,p.right,p.top,p.bottom].every(Number.isFinite));
        console.assert(platforms.length>0, 'platforms should be populated');
        // Shadow should horizontally track the player
        shadowEl.style.left = (player.x*100)+'%';
        console.assert(shadowEl.style.left.endsWith('%'), 'shadow left should be in % units');
        console.assert(finiteBounds, 'platform bounds should be finite numbers');
        console.groupEnd();
      })();

      // Start
      reducedBtn.textContent = reducedMotion ? 'Enable motion' : 'Reduce motion';
      camY = window.scrollY | 0; player.y = innerHeight*0.5;
      last = performance.now();
      if(platforms.length===0) buildPlatforms();
      loopHandle = requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
