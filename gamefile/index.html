<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scroll‑Player Article</title>
  <style>
    :root{
      --bg:#0b1220; --ink:#e9eefc; --muted:#a9b4d6; --accent:#62d0ff; --accent2:#ffd166;
      --card:#121a2e; --shadow:rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; font: 16px/1.65 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Apple Color Emoji, Segoe UI Emoji; color:var(--ink); background:radial-gradient(1200px 700px at 10% -10%, #12203b 0%, #0b1220 60%);}    
    main{width:min(920px, 92vw); margin:0 auto; padding:18vh 0 24vh 0;}
    section{background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01)); border:1px solid rgba(255,255,255,.06); border-radius:20px; padding:28px; margin:48px 0; box-shadow:0 12px 30px var(--shadow);}
    h1,h2{margin:0 0 12px 0; line-height:1.2}
    h1{font-size:clamp(28px, 3.5vw, 46px)}
    h2{font-size:clamp(22px, 2.4vw, 30px); color:var(--accent)}
    p{margin:10px 0}

    /* Player (always centered vertically; world scrolls under it) */
    #player{
      position:fixed; z-index:20; left:50%; top:50%; width:44px; height:44px; transform:translate(-50%, -50%);
      border-radius:12px; background:linear-gradient(160deg, var(--accent), #7ee0ff);
      box-shadow:0 10px 24px rgba(0,0,0,.45), inset 0 2px 6px rgba(255,255,255,.5);
      outline:2px solid rgba(255,255,255,.35);
    }
    /* A little face */
    #player::before,#player::after{content:""; position:absolute; top:14px; width:6px; height:6px; background:#0b1220; border-radius:50%}
    #player::before{left:12px} #player::after{right:12px}
    #shadow{position:fixed; left:50%; top:calc(50% + 28px); width:60px; height:14px; transform:translateX(-50%); background:radial-gradient(ellipse at center, rgba(0,0,0,.45), rgba(0,0,0,0) 60%); filter:blur(3px); z-index:10}

    /* HUD */
    #hud{position:fixed; z-index:30; top:16px; left:50%; transform:translateX(-50%); background:rgba(10,16,28,.7); backdrop-filter:blur(8px); border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:10px 14px; display:flex; gap:14px; align-items:center}
    #hud .pill{font-size:13px; color:var(--muted)}
    #hud kbd{background:#10182b; border:1px solid rgba(255,255,255,.1); border-radius:8px; padding:2px 6px; box-shadow:inset 0 1px 0 rgba(255,255,255,.08)}
    #hud button{cursor:pointer; border:1px solid rgba(255,255,255,.12); background:#0f1830; color:var(--ink); border-radius:10px; padding:6px 10px; font-weight:600}
    #hud button:hover{background:#0e1a36}

    /* Progress bar */
    #progress{position:fixed; z-index:25; right:20px; top:20px; width:10px; height:60vh; border-radius:999px; background:rgba(255,255,255,.08); overflow:hidden;}
    #progress>span{display:block; width:100%; height:0%; background:linear-gradient(180deg, var(--accent2), var(--accent));}

    /* Section highlight when near center */
    section.in-view{outline:2px solid rgba(255,255,255,.25); box-shadow:0 18px 40px rgba(0,0,0,.6)}

    /* Reduced motion */
    @media (prefers-reduced-motion: reduce){
      html{scroll-behavior:auto}
    }
  </style>
</head>
<body>
  <div id="player" aria-hidden="true" title="Use WASD/←→ to move, Space to jump"></div>
  <div id="shadow" aria-hidden="true"></div>

  <div id="hud" role="status" aria-live="polite">
    <span class="pill">Controls: <kbd>←/→</kbd> move &nbsp; <kbd>Space</kbd>/<kbd>W</kbd> jump &nbsp; <kbd>↓</kbd>/<kbd>S</kbd> dive</span>
    <button id="toggleReduced">Reduce motion</button>
  </div>
  <div id="progress" aria-hidden="true"><span></span></div>

  <main id="article">
    <header style="text-align:center; margin-bottom:36px">
      <h1>Scroll‑Player Article</h1>
      <p style="color:var(--muted); max-width:62ch; margin:8px auto 0">Jump to read! The player stays centered, and the world scrolls beneath you. Great for playful docs, devlogs, or story chapters.</p>
    </header>

    <!-- Sample tall content: replace with your real article -->
    <section><h2>1) Opening</h2><p>Make a site where the player’s jump nudges the article downward. It’s keyboard‑friendly and works without any build tools—perfect for GitHub Pages.</p><p>Tip: split your long post into clear sections. The progress bar on the right fills as you “descend.”</p></section>
    <section><h2>2) Idea</h2><p>As the cube “falls,” gravity scrolls the page. Press <strong>Space</strong> to jump (slows descent or lifts you back toward earlier paragraphs), and press <strong>↓</strong> to dive down to the next chunk.</p></section>
    <section><h2>3) Use cases</h2><p>Devlogs, multi‑chapter docs, or a whimsical CYOA. Add anchors, images, and code blocks—everything is just normal HTML inside sections.</p></section>
    <section><h2>4) Tips</h2><p>Keep paragraphs short. Use headings every few screens so players have targets. Avoid giant images without <code>width</code>/<code>height</code> to prevent layout shift.</p></section>
    <section><h2>5) Performance</h2><p>This demo uses a tiny physics loop tied to <code>requestAnimationFrame</code> and updates <code>scrollTop</code> via a smoothed camera.</p></section>
    <section><h2>6) Accessibility</h2><p>All text is semantic HTML; the toy layer doesn’t block selection. There’s a <em>Reduce motion</em> button for sensitive users.</p></section>
    <section><h2>7) Extend</h2><p>Add parallax backgrounds, coins, or section‑based challenges (press a key to reveal the next paragraph). Or add a button to switch to plain scroll mode.</p></section>
    <section><h2>8) Finish</h2><p>Swap these demo sections for your own content, push to <code>REPO/subfolder/</code>, and link it from your portal.</p></section>
  </main>

  <script>
    (function(){
      const progressEl = document.querySelector('#progress>span');
      const sections = Array.from(document.querySelectorAll('section'));
      const reducedBtn = document.getElementById('toggleReduced');

      let reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      // World / camera
      let docH = 0, camY = 0, targetCamY = 0;
      const recalc = () => {
        // Using body.scrollHeight is more robust than documentElement when borders exist
        docH = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
        camY = window.scrollY | 0; // current scroll
      };
      recalc();
      addEventListener('resize', recalc);
      addEventListener('load', recalc);

      // Player state in world coordinates (y increases downward like the DOM)
      const player = { x: 0.5, // 0..1 across the viewport
                       y: window.innerHeight * 0.5, // world y
                       vx: 0,
                       vy: 0,
                       width: 44,
                       height: 44 };

      // Physics constants
      const G = 2400;              // px/s^2
      const JUMP = 900;            // initial jump velocity (upwards => negative vy)
      const MOVE = 520;            // horizontal speed px/s
      const AIR_DRAG = 0.015;      // fractional drag per frame
      const CAM_SMOOTH = 0.12;     // camera follow smoothing
      const MAX_FALL = 1600;       // clamp

      // Input
      const keys = new Set();
      addEventListener('keydown', (e)=>{
        if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
        keys.add(e.key);
      });
      addEventListener('keyup', (e)=> keys.delete(e.key));

      reducedBtn.addEventListener('click', ()=>{
        reducedMotion = !reducedMotion;
        reducedBtn.textContent = reducedMotion ? 'Enable motion' : 'Reduce motion';
        if(reducedMotion){
          // Snap camera to native scroll and bail out
          cancelAnimationFrame(loopHandle);
          document.body.style.overflowY = 'auto';
          progressTick();
        }else{
          document.body.style.overflowY = 'hidden';
          last = performance.now();
          loopHandle = requestAnimationFrame(loop);
        }
      });

      // Allow native scroll when reduced motion
      if(reducedMotion){
        document.body.style.overflowY = 'auto';
      }else{
        document.body.style.overflowY = 'hidden';
      }

      // Intersection highlight near center
      const highlightInView = ()=>{
        const center = window.scrollY + innerHeight/2;
        sections.forEach(s=>{
          const r = s.getBoundingClientRect();
          const top = r.top + window.scrollY;
          const mid = top + r.height/2;
          const near = Math.abs(mid - center) < innerHeight*0.25;
          s.classList.toggle('in-view', near);
        });
      };

      // Progress bar
      const progressTick = ()=>{
        const maxScroll = Math.max(1, (docH - innerHeight));
        const pct = Math.min(1, Math.max(0, window.scrollY / maxScroll));
        progressEl.style.height = (pct*100).toFixed(1)+'%';
        highlightInView();
      };
      addEventListener('scroll', progressTick, {passive:true});

      // Game loop
      let last = performance.now();
      let loopHandle = 0;

      function loop(now){
        const dt = Math.min(0.033, (now - last) / 1000);
        last = now;

        if(!reducedMotion){
          // Horizontal
          const left = keys.has('ArrowLeft') || keys.has('a') || keys.has('A');
          const right = keys.has('ArrowRight') || keys.has('d') || keys.has('D');
          let dvx = 0; if(left) dvx -= MOVE; if(right) dvx += MOVE;
          player.vx = dvx; // instantaneous for snappy feel
          player.x += player.vx * dt / innerWidth; // normalize to viewport width
          player.x = Math.max(0.06, Math.min(0.94, player.x));
          document.getElementById('player').style.left = (player.x*100)+'%';

          // Vertical
          // Gravity pulls down (positive vy). Jump gives upward impulse.
          const onTopBound = player.y <= innerHeight*0.5 + 1; // world ceiling
          const onBottomBound = player.y >= Math.max(innerHeight*0.5, docH - innerHeight*0.5) - 1; // world floor

          // Jump
          if((keys.has(' ') || keys.has('ArrowUp') || keys.has('w') || keys.has('W')) && !onTopBound){
            // only apply on key press edges? For simplicity, apply small impulse when key is down and moving downward
            if(player.vy > -JUMP*0.6) player.vy = -JUMP; // strong single jump
          }
          // Dive
          if(keys.has('ArrowDown') || keys.has('s') || keys.has('S')){
            player.vy += G * 0.8 * dt;
          }

          // Integrate
          player.vy += G * dt; // gravity
          if(player.vy > MAX_FALL) player.vy = MAX_FALL;
          player.y += player.vy * dt;

          // Clamp to world
          const minY = innerHeight*0.5;
          const maxY = Math.max(minY, docH - innerHeight*0.5);
          if(player.y < minY){ player.y = minY; if(player.vy < 0) player.vy *= -0.25; }
          if(player.y > maxY){ player.y = maxY; if(player.vy > 0) player.vy = 0; }

          // Camera follow (smooth)
          targetCamY = Math.max(0, Math.min(docH - innerHeight, player.y - innerHeight*0.5));
          camY += (targetCamY - camY) * CAM_SMOOTH;
          window.scrollTo(0, camY|0);

          // Fake squash/stretch via shadow size
          const vyNorm = Math.max(-JUMP, Math.min(MAX_FALL, player.vy)) / MAX_FALL;
          const shadow = document.getElementById('shadow');
          const w = 60 + 20 * Math.max(0, vyNorm);
          shadow.style.width = w.toFixed(0)+'px';
        }

        progressTick();
        loopHandle = requestAnimationFrame(loop);
      }

      // Start
      reducedBtn.textContent = reducedMotion ? 'Enable motion' : 'Reduce motion';
      camY = window.scrollY | 0; player.y = innerHeight*0.5; // start at top
      last = performance.now();
      loopHandle = requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
